# 레트로 강의

### 1. 게임 엔지의 원리: 게임 오브젝트와 컴포넌트

상속과 컴포넌트 :

상속으로 코딩했을 때의 문제들을 해결하기 위해 유니티는 컴포넌트 방식을 사용함.

컴포넌트의 장점 :

1. 유연한 재사용
2. 기획자의 프로그래머 의존도 낮아짐
3. 독립성 덕분에 추가와 삭제가 쉽다.



### MonoBehaviour

- 유니티의 모든 컴포넌트들은 MonoBehaviour클래스를 포함한다
- MonoBehaviour을 상속하게 된다면?
  - 컴포넌트로서 게임 오브젝트에게 추가 될 수있음
  - 유니티의 통제를 받게 됨
  - 유니티 이벤트 메세지를 감지할 수 있게 된다.



### 변수

- 숫자형 변수
  - int
  - float
  - double
- 논리형 변수
  - bool
- 문자형 변수
  - char //문자
  - string //문자열
- 할당하는 값을 기준으로 타입을 결정하는 변수
  - var



### 형변환

- 형변환 캐스팅
- 자동 형변환 -> 잃어버리는 정보가 없으면 자동
- 수동 형변환 -> 잃어버리는 정보가 있으면 변환되는 타입을 앞에 적어줘야함.

```
int height = 170;
float heightDetail = 170.3f;
heightDetail = height //자동 형변환
height = (int)heightDetail // 수동 형변환
```



### 분기문

#### switch문

```
switch(year)

{
	case 2012:
		Debug.Log("레미제라블")
		break; //하나의 케이스마다 적어줘야함
	case 2013:
		Debug.Log("레미제라블")
		break; //하나의 케이스마다 적어줘야함
	default:
		Debug.Log("레미제라블")
		break; //하나의 케이스마다 적어줘야함
}
```



### 반복문

#### Do While문

```
do
{
	한번은 무조건 실행
}
while(조건)
{
	조건에 맞으면 실행
}
```



### 클래스와 오브젝트

#### 객체 지향 프로그래밍(OOP)



### call by reference

### call by value

### 벡터란?

Vector3 (x,y,z) -> 3d

Vector2 (x,y) -> 2d

1. 벡터는 길이와 방향을 가진다.
   1. 절대좌표
   2. 상대좌표

벡터의 크기.



### static

### 오버로드



### List

나중에 추가된 경우 System.Collections.Generic;을 써줘야함

List<type> 리스트 이름 = new List<type>(); <- 리스트 요소 추가제거에 한계가 있던 c#배열의 단점을 해결하기 위해 도입된듯

요소 추가

Add();

요소 제거

RemoveAt(없애줄 인덱스);

1. 크기를 미리 정해둘 필요가 없음.

리스트 길이

Count

### 싱글톤

 많은 오브젝트들이 접근해야 하고 유일한 변수가 존재할때 사용하기 좋은 디자인 패턴



### 코루틴

StartCoroutine(함수) <- 함수 쓰는 두가지 방식 함수(), "함수"

StopCoroutine() <- 코루틴 중단

#### IEnumerator -> yield return new WaitForSeconds();

1. 코드 중간에 대기시간을 삽입할 수 있다.
2. 병렬처리가능 <- 자바스크립트의 비동기같음. 

### RGBA

#### 상속과 다형성

public 모두 개방

private 개방안함

protected 일부 개방, 자식한테만 접근



#### 오버라이드

부모클래스의 함수를 자식클래스에서 덮어씌어서 자신의 것으로 만드는것



virtual - 자식이 함수를 덮어씌우게 할수 있음.



#### 인터페이스

상속하는 상대에게 강제하는것.

1. 인터페이스를 상속받으면 인터페이스 함수를 무조건 써야함.
2. 인터페이스 함수는 내부 내용이 없음(한계)

#### 추상클래스

abstract - 강제로 써야하지만 다른 내용도 함께 상속



#### 프로퍼티

```
{}
get{

}
set{

}
//변수처럼 사용하지만 내부에 함수들이 작동한다.
```



게임 재시작 : UnityEngine.SecenManagement 필요



#### 이벤트와 델리게이트

#### 액션

입력도 리턴도 없는 델리게이트를 자주 쓰니깐 만들어둔 델리게이트 클래스

using System 선언해줘야함

#### 람다함수

에로우 펑션??

#### 제네릭

타입이름 임의 설정 가능





#### 애니메이션

### FSM



#### 루트모션

체크되어있으면 애니메이션에 의해 게임 좌표값이  변경될수 있음



#### 레이어

아래에 있는 레이어가 위에있는 레이어를 덮어쓰기 때문에 생각하고 배치

신체별로 나눠서 돌릴 수 있음



#### Inverse Kinematic



### UGUI

Legacy UI 시스템, NGUI -> UGUI 이전 시스템



#### 캔버스

render mode



#### 앵커, 피벗, 포지션

앵커 : 부모?(캔버스)안에서의 좌표, min과 max가 같으면 절대, 다르면 상대

피벗 : 자기 자신 안에서의 중심



#### 텍스트

#### 마스크 컴포넌트

자식 요소가 밖으로 나가면 잘라버림,

#### rect mask

이미지가 없어도 밖으로 나가면 자름

#### 그림자 외곽선

### 인터렉션 컴포넌트

마우스나 터치 이벤트를 받는 컴포넌트

슬렉터블

인터렉션 트렌지션 네비게이션